import axios from 'axios';
// let a = 6;
// let b = false;
// let c = "12";
// let d = 1;
// let result = a + d + c + b;
// console.log(result);
//*Спочатку виконається звичайна операція додавання - 6+1 =7. Потім два рази відбудеться конкатенація - 7 + “12” = “712" i “712” + false = “712false”

// console.log(typeof typeof 1);
//* Спочатку виконається typeof 1, що поверне "number". Потім виконається typeof "number", що поверне "string". Отже, результатом буде "string" */

// for (let i = 6; i > 3; i--) {}
// console.log(i);
//* Цикл for не виконається жодного разу, оскільки умова i > 3 не є істинною для початкового значення i = 6. Тому змінна i не буде оголошена в цій області видимості, і спроба доступу до неї за межами циклу призведе до помилки ReferenceError. Якщо ви хочете, щоб цикл виконався, потрібно змінити умову на i >= 3 або зменшити початкове значення i.

// let firstName = null;
// let nickName = "Суперкодер";

// console.log(firstName ?? nickName ?? "Анонім");
//* Використання оператора нульового злиття (??) дозволяє повернути перше значення, яке не є null або undefined.
//* У цьому випадку, оскільки firstName дорівнює null, буде повернуто nickName, тобто "Суперкодер". Якщо б обидва значення були null або undefined, то було б повернуто "Анонім".

// const fruits = ["Яблуко", "Груша", "Апельсин"];
// const shoppingCart = fruits;
// shoppingCart.push("Банан");
// console.log(fruits.length);
//* Оскільки масиви в JavaScript передаються за посиланням, зміна одного з них вплине на інший. Тому після додавання "Банан" до shoppingCart, довжина масиву fruits також зміниться. Результат буде 4, оскільки в масиві тепер чотири елементи: ["Яблуко", "Груша", "Апельсин", "Банан"].

//!Шпаргалка по методам масивів:
// split/join -- перетворює рядок на масив і назад.
// push () -- додає елементи до кінця,
// pop() -- видаляє елемент з кінця,
// shift() -- видаляє елемент із початку,
// unshift() - додає елементи на початок.
// splice(index, deleteIndex, ...arr) -- починаючи з індексу index, видаляє deleteIndex елементів і вставляє arr.
// slice(start, end) -- створює новий масив, копіюючи елементи з позиції start до end (не включаючи end).
// Функція повинна робити лише те, що очевидно мається на увазі її назвою. І це має бути однією дією. Якщо коротко і зрозуміло: Одна функція -- одна дія.
// Якщо функція має повернути бульове значення, не обов’язково повертати з функції true чи false. Скоріш за все ви можете повернути з функції безпосередньо саму умову з if. Наприклад, замість:
// function isAdult(age) {
//   if (age >= 18) {
//     return true;
//   } else {
//     return false;
//   }
// }
// //!краще написати:
// function isAdult(age) {
//   return age >= 18;
// }

//! Шпаргалка з оголошення функцій у JS:
// //* Функціональний вираз (function expression)
// const greet = function (name) {
//   return `Hello, ${name}`;
// };

//*Оголошення функції (function declaration)
// function greet(name) {
//   return `Hello, ${name}!`;
// }
//* Для того, щоб щось повернути з функції/методу або умови, можна використовувати оператор return. Також з функції можна повертати відразу будь-який тип даних, наприклад return 'hello' // (повернемо рядок) чи return true // (повернемо буль) чи return [1, 2] // (повернемо масив)
//* Паттерн раннє повернення, говорить про те, що якщо умова всередині нашего if повертає true, то нам одразу же треба щось повернути із тіла цієї умови, з допомогою return.
//*Не забувайте, що оператор = це оператор присвоєння, а не порівняння.

//! Декілька лайфхаків при роботі з масивами.
//* Як швидко очистити масив
// const fruits = [
//   "banana",
//   "apple",
//   "orange",
//   "watermelon",
//   "apple",
//   "orange",
//   "grape",
//   "apple",
// ];
// fruits.length = 0;
// console.log(fruits); // поверне []

//* Як об'єднати більше двох масивів
// const fruits = ["apple", "banana", "orange"];
// const meat = ["poultry", "beef", "fish"];
// const vegetables = ["potato", "tomato", "cucumber"];
// const food = [...fruits, ...meat, ...vegetables];
// console.log(food); // поверне ["apple", "banana", "orange", "poultry", "beef", "fish", "potato", "tomato", "cucumber"]

//* Як отримати рандомне значення масиву
// const fruits = [
//   "banana",
//   "apple",
//   "orange",
//   "watermelon",
//   "apple",
//   "orange",
//   "grape",
//   "apple",
// ];
// const randomFruit = fruits[Math.floor(Math.random() * fruits.length)];
// console.log(randomFruit); // поверне рандомний фрукт із масиву

// function fillArray(min, max) {
//   let arr = [];
//   for (let i = min; i <= max; i += 2) {
//     return arr.push(i);
//   }
// }

// console.log(fillArray(2, 10));
//*Вірна відповідь - 1.
//*Функція fillArray на першій ітерації циклу поверне результат роботи push(), а пуш повертає оновлену довжину масиву після додавання до нього елементів. Враховуючи, що початковий масив arr у нас був пустий, то пуш додасть до масиву двійку і поверне 1, так як довжина масиву стане 1.

//! Об'єкти в JS
//*Об‘єкти в js - це одна з найголовніших і важливіших тем, які обов‘язково потрібно засвоїти та зрозуміти, тому що без них ніяк :man-shrugging:
//?Розберіться з тим, що таке поля об‘єкта, значення, ключі та методи.
//*При роботі з об‘єктами обов‘язково потрібно пам‘ятати - отримати доступ до значення можна, використовуючи звернення через крапку до ключа або використовувати квадратні дужки, наприклад є об’єкт const obj = {name: "John"}, щоб отримати "John" ми можемо використовувати такий запис obj.name - (отримаємо "John") або obj['name'] (отримаємо "John").
//*Найчастіше використовуються квадратні дужки при зверненні до ключа, коли дані до нас приходять динамічно і ми заздалегідь не можемо знати ім‘я самого ключа. Ось один з прикладів такого використання:
// const user = {
//   name: "John",
//   age: 20,
//   hobby: "tenis",
// };
// const userKeys = Object.keys(user);
// for (const key of userKeys) {
//   console.log(user[key]);
// }

//* Можна отримати масив ключів об’єкта за допомогою Object.keys(obj) або можемо отримати масив значень за допомогою Object.values(obj).
//*Також можна отримати ключ зі значенням за допомогою Object.entries(obj), результатом цієї операції буде масив масивів, на прикладі вищезгаданого obj, результат буде [['name', 'John']].
//*Перебирати об‘єкт можна за допомогою циклу for in, синтаксис такий самий як і for of. Розберіться з його використанням.
//*Так само потрібно розуміти, що таке конструктор об’єкта і для чого потрібен оператор new.
//*Буде лише плюсом, якщо вивчили дод. матеріали самостійно (крім конспекту).

// const password = "true";
// const myKey = password;

// const obj = {
//   [myKey]: false,
// };

// console.log(obj);
//* Виведе { true: false }. Тут ми використовуємо динамічне створення ключа об'єкта, де значення myKey (яке дорівнює "true") стає ключем об'єкта obj, а його значенням є false. Таким чином, ми отримуємо об'єкт з ключем "true" і значенням false.
//* В цьому завданні використаний синтаксис обчислювальних властивостей. В якості ключа обʼєкта obj ми підставляємо значення змінної myKey в яку ми попередньо записали значення змінної password, тому маємо ключ ‘true’ і значення false.

// const user = {
//   name: "Peter",
//   age: 30,
//   pet: "cat",
//   "Wether is good": false,
// };
//* Вірна відповідь - console.log(user["Wether is good"]
//* При звертанні до ключа через крапку необхідно, щоб цей ключ був іменован по правилам іменування змінних (без пробілів, без спеціальних символів і т.д.). Доступ через [] дозволяє обходити це правило.

//* Ознайомтеся з функціями вищого порядку, стрілочними та чистими функціями та у яких випадках їх використовують.
//*Розгляньте імперативний та декларативний підхід до написання коду та побачите сучасність останнього.
//* Навчіться використовувати функціональні методи масивів - це ще одна крута штука, без якої в розробці не обійтися.
//* Потрібно розуміти, де і коли правильно використовувати той чи нший метод, для цього необхідно знати, що повертає метод, який ви використовуєте.
//* Буде лише плюсом, якщо вивчили дод. матеріали самостійно (крім конспекту та задач).

//* Щоразу, коли потрібно обробити масив, не обов‘язково використовувати цикли або винаходити велосипед. Найімовірніше, це вже зробили за вас.
//* Пошукайте відповідний метод. У більшості випадків завдання можна буде вирішити за допомогою методів map(), filter(), reduce() або spread-оператора.
//* Ніколи не завадить вміння застосовувати методи slice(), some(), flatMap() тощо. Використовуйте їх, коли це буде доцільно.
//* Завжди пам‘ятайте, які методи створюють новий масив, а які модифікують (мутують) вже існуючий. Інакше можна наламати дров.
//* Метод slice() та spread-оператор роблять поверхневу копію масиву. Тому масиви та підмасиви будуть посилатися на один і той самий об‘єкт у пам’яті.
//* “Старі” методи, що змінюють масив, мають сучасні аналоги. Ретельно вибирайте використовувані методи.

// const arr = [2, 4, 6];
// const result = arr.filter((el) => el * 2);
// console.log(result);
//* Метод filter повертає копію масиву з усіма елементами, які пройшли перевірку. Його колбек повинен повертати "truthy" значення, щоб залишити елемент в новому масиві, або ж "falsy" значення щоб відфільтрувати його.

// const products = [
//   { name: "Apple", category: "fruits", price: 1.2, stock: 50 },
//   { name: "Banana", category: "fruits", price: 0.8, stock: 100 },
//   { name: "Carrot", category: "vegetables", price: 0.5, stock: 200 },
//   { name: "Broccoli", category: "vegetables", price: 1.0, stock: 150 },
//   { name: "Milk", category: "dairy", price: 1.5, stock: 20 },
//   { name: "Cheese", category: "dairy", price: 2.5, stock: 5 },
//   { name: "Chicken", category: "meat", price: 5.0, stock: 30 },
//   { name: "Beef", category: "meat", price: 7.0, stock: 25 },
// ];

// function areAllDairyStockAboveTen(products) {
//   return products
//     .filter((product) => product.category === "dairy")
//     .every((product) => product.stock > 10);
// }

// console.log(areAllDairyStockAboveTen(products));
//*Функція areAllDairyStockAboveTen фільтрує продукти за категорією "dairy" і використовує метод every для перевірки, чи всі продукти мають кількість на складі більше 10. Оскільки Cheese має лише 5 одиниць на складі, відповідь буде false.

//*Беремось за інформацію шостого модуля :muscle:
//* Починайте вирішувати домашнє завдання після того, як повністю пропрацювали конспект як мінімум, так само будуть дуже корисні додаткові матеріали.
//* Ключове слово this і контекст виконання функції також стануть у нагоді при виконанні домашнього завдання, вивчіть як працює метод для прив‘язки контексту bind(), а також методи call() і apply() для виклику функції з потрібним контекстом.
//* Об‘єкти ви вже пройшли і прийшло невелике розуміння, як працює js з ними. Тепер переходимо до ще однієї цікавої теми – це класи, конструктори та прототипи. При виконанні домашнього завдання, ви будете працювати з класами та з конструкторами класів, тому необхідно розібратися з тим, як створюється клас у js, як написати правильний конструктор класу та що таке прототип класу.
//* Успадкування, інкапсуляція, абстракція, поліморфізм – це основні принципи ООП (об’єктно-орієнтованого програмування) та їх так само потрібно зрозуміти та прийняти. Тому залишаю внизу посилання, які допоможуть у виконанні дз або як додатковий матеріал.
//* :pushpin:Додаткові матеріали
//! Ключове слово this
//! bind, call і apply
//! Класи в js, конструктори класів: Classes - JavaScript | MDN ES6 Classes in Depth
//! Вступ в ООП
//! Прототипи
//* Методи об’єктів та класів не обов’язково мають щось повертати, багато методів використовуються для зміни значень чи додавання/видалення елементів.

// const object = {
//   message: "Hello, World",
//   getMessage() {
//     const message = "Hello, Earth";
//     return this.message;
//   },
// };
// console.log(object.getMessage());
// Hello, World;
//* У цьому прикладі метод getMessage повертає значення this.message, яке є "Hello, World". Змінна message всередині методу не впливає на значення this.message, оскільки вона оголошена локально в межах методу і не є властивістю об'єкта. Тому результатом буде "Hello, World".

//* Трохи теорії з пройденого (ну майже) матеріалу 6 модуля.
//* Для оголошення приватних властивостей класу використовуємо спеціальний символ #. Оголошення приватних властивостей до ініціалізації в конструкторі - обов‘язково. Наприклад, #someValue і потім тільки оголосити конструктор:
//* До речі, можна зустріти (нагуглити) таке написання : _someValue; Це не синтаксис мови: є добре відома угода між програмістами, що такі властивості та методи не повинні бути доступні ззовні. Більшість програмістів дотримуються цієї угоди. Ще це називають захищеною властивістю. Важливо відзначити -- ці властивості успадковуються.
//* Статичні властивості і методи доступні тільки на самому класі, тож звертання до них через this або всередині екземпляра поверне undefined. Звертатись до статичних властивостей і методів можна тільки через ім’я самого класу. Оголошуються вони також до конструктора за допомогою ключового слова static.
//* Ключове слово extends використовують для оголошення класів або у виразах класу для створення дочірніх класів. Дочірні класи отримують властивості батьківських класів, а також дають можливість додати нові властивості та змінити запозичені.
//* Ключове слово super викликає функції з батька об’єкта, включаючи його конструктор. Його слід використовувати до ключового слова this в конструкторі (інакше буде помилка); якщо батьківський конструктор приймає аргументи, можна передати їх, як аргументи в super(arguments);
// class Animal {
//   constructor(name) {
//     this.name = name;
//   }
// }

// class Dog extends Animal {
//   constructor(name, breed) {
//     super(name); // виклик конструктора батьківського класу
//     this.breed = breed;
//   }
// }
//*якщо дочірній клас має метод з таким же ім'ям, як у батьківському класі, можна   викликати метод батьківського класу, використовуючи `super.X()`.
// class Animal {
//   speak() {
//     console.log("Animal speaks");
//   }
// }

// class Dog extends Animal {
//   speak() {
//     super.speak(); // виклик методу батьківського класу
//     console.log("Dog barks");
//   }
// }

// const person = { name: "Mango" };

// function sayHi(age) {
//   return `${this.name} is ${age}`;
// }

// console.log(sayHi.call(person, 18)); //* В першому консолі використаний метод call() - він викликає функцію з привʼязаним контекстом і тому ми побачимо Mango is 18,
// console.log(sayHi.bind(person, 18)); //* в консолі використаний bind - він повертає копію функції з привʼязаним контекстом і тому побачимо в консолі функцію.

//! DOM (Document Object Model) – це спосіб, за допомогою якого JavaScript може взаємодіяти з HTML-елементами на сторінці. Це основа для створення динамічних інтерфейсів користувача.
//* Кожен елемент на веб-сторінці представлений у вигляді об'єкта, з яким можна працювати через JS. Для того, щоб отримати доступ до елемента, використовуються методи, як-от:
//* document.getElementById('id') – шукає елемент за його id.
//* document.querySelector('.class') – повертає перший елемент, що відповідає CSS-селектору.
//* document.querySelectorAll('tag') – повертає всі елементи, що відповідають певному тегу або селектору.
//! В більшості випадків вам будуть корисні наступні селектори для пошуку елементів в ДОМ (насправді це звичайні селектори, якими ви користуєтесь в css):
//* .myClass - селектор класу
//* #myId - id селектор
//* div.myClass - комбінований селектор (в цьому прикладі <div>з класом myClass )
//* div > p - дочірній селектор (<p>, що є безпосередніми дочірніми елементами <div>)
//* div p - селектор нащадків (<p> всередині <div>)
//* [attribute] - селектор атрибута (елемент з наявністю атрибута)
//* [attribute="value"] – елемент з конкретним значенням атрибута.
//! Події – це дії, що відбуваються на сторінці (наприклад, клік мишею, натискання клавіші тощо). Щоб "слухати" події, ми використовуємо метод addEventListener. Це дозволяє виконувати певний код, коли подія відбувається.
//* Основні події, які варто знати:
//* click – спрацьовує при натисканні на елемент.
//* input – реагує на введення даних у текстове поле.
//* submit – спрацьовує при відправці форми.
//* keydown та keyup – реагують на натискання і відпускання клавіші.

//! Що варто знати про обробники подій:
//* Можна додавати кілька обробників до одного елемента.
//* Є можливість "зупинити" виконання стандартної поведінки браузера за допомогою event.preventDefault(), наприклад, для блокування перезавантаження сторінки при відправці форми.

// const link = document.querySelector(".link");
// console.log(link.href); // "https://goit.global"
// link.href = "https://neo.goit.global";
// console.log(link.href); // "https://neo.goit.global"
//* У цьому прикладі ми отримуємо елемент з класом "link" і виводимо його атрибут href у консоль. Потім змінюємо значення href на нове посилання і знову виводимо його у консоль. Це демонструє, як можна працювати з атрибутами елементів у DOM.
//* Щоб змінити атрибут елемента, можна використовувати властивість element.href або метод element.setAttribute('href', 'нове_значення').

// index.html є розмітка:
{
  /* <div id="container">
  <p>Перший параграф</p>
  <p>Другий параграф</p>
  <p>Третій параграф</p>
</div>;
const container = document.getElementById("container"); */
}
//! 1. document.querySelectorAll("p").firstElementChild — ❌ querySelectorAll повертає NodeList, а не один елемент. У NodeList немає firstElementChild.

//* 2. document.querySelector("#container").firstElementChild — ✅ Це вірно: document.querySelector("#container") — знаходить <div id="container">.firstElementChild — повертає перший <p> у цьому контейнері, тобто <p>Перший параграф</p>

//! 3. document.querySelector("p").firstElementChild — ❌ document.querySelector("p") — знайде перший <p>, але у нього немає дочірніх елементів, тільки текст. Тому .firstElementChild поверне null.

//! 4. document.querySelector(".container").firstElementChild — ❌ У HTML елемент має id="container", а не class="container". Тому цей селектор нічого не знайде.
// const button = document.querySelector(".my-button");

// const handleClick = () => {
//   console.log("The button was pressed and now the next image will appear");
// };

// button.addEventListener("click", handleClick);

//* Завдання наступне:
//* В index.html є розмітка:
// <span id="text">Наведіть мишу на цей текст</span>;
//? Що відбудеться при виконанні цього скрипта?
// const paragraph = document.getElementById("text");
// paragraph.addEventListener("mouseenter", function () {
//   this.style.backgroundColor = "red";
// });
//? Варіанти відповіді: Error - :flag-ua:; Колір текста стане червоним - :blue_heart:; Нічого не відбудеться - :yellow_heart:; Фон стане червоним - :heart_on_fire: Не спішіть, подумайте. Правильну відповідь поставте у вигляді відповідних реакцій. В обговореннях відповіді писати не потрібно)Ввечері в обговореннях надам вірну відповідь з поясненнями.
//* Правильна відповідь - Фон стане червоним. Через getElementById знаходимо елемент в розмітці, додаємо на нього слухача “mouseenter” - це подія миші, коли вона наводиться на елемент. Всередині обробника слухача події через this звертаємось до самого елемента, на якому подія, і додаємо на нього червоний бекграунд.

//! Делегування подій – потужна техніка для оптимізації роботи з подіями. Замість того, щоб призначати події кожному елементу окремо, ми можемо призначити обробник події спільному предку, а подія "спливатиме" через DOM. Це зручно, коли у нас є багато однотипних елементів або елементи додаються динамічно.
//* Основні підходи до делегування подій включають:
//* 1 Використання event.target для перевірки цільового елемента, через nodeName.
// document.querySelector("ul").addEventListener("click", function (event) {
//   // Перевіряємо, чи подія відбулася на елементі <li>
//   if (event.target.nodeName === "LI") {
//     console.log("Натиснуто на елемент списку:", event.target.textContent);
//   }
// });
// //* Використання класів або атрибутів для точного визначення елемента.
// document.querySelector(".parent").addEventListener("click", function (event) {
//   // Перевіряємо, чи елемент має клас 'button'
//   if (event.target.classList.contains("button")) {
//     console.log("Натиснуто на кнопку:", event.target.textContent);
//   }
// });
// //* Використання методу closest() для роботи з ієрархією DOM.
// document
//   .querySelector(".container")
//   .addEventListener("click", function (event) {
//     // Шукаємо найближчого предка елемента, що відповідає певному селектору
//     const button = event.target.closest(".button");
//     if (button) {
//       console.log("Натиснуто на кнопку:", button.textContent);
//     }
//   });
//* Бібліотеки в JS допомагають спростити складні або рутинні операції. Ви можете знайти багато цікавих і корисних бібліотек для вирішення своєї задачі, використовуючі такі популярні ресурси, як cdn чи npm, або просто погугливши (тут ви обов’язково знайдете потрібне рішення).
//* Документація до бібліотеки зазвичай поділяється на кілька основних розділів. Важливо вміти з нею працювати, щоб швидко знайти потрібну інформацію: Огляд, Інсталяція, Використання, API Reference, Параметри, Приклади.

//! Деструктуризація — це зручний спосіб "розпаковки" значень з масивів або властивостей з об’єктів у змінні. Вона спрощує код, особливо коли потрібно працювати з великими масивами чи об'єктами.
//! Важливі моменти:
//* Розберіться, як працюють обробники подій і чому делегування подій може бути корисним у певних ситуаціях.
//* Починайте читати документацію бібліотек, це не так просто як може здатись, але до цього необхідно звикати:wink:

//* Пропоную вам задачку, яку ви можете вирішити для вдосконалення своїх навичок по сьомому модулю.
//! Завдання наступне:

// <div id="container">
//   <p>Перший параграф</p>
//   <p>Другий параграф</p>
//   <p>Третій параграф</p>
// </div>;
//? Як отримати посилання на елемент з текстом «Перший параграф»?
// document.querySelector("#container").firstElementChild;
//* Перевірка:
// console.log("Контейнер:", container); //* Контейнер: <div id=​"container">​…​</div>​<p>​Перший параграф​</p>​<p>​Другий параграф​</p>​<p>​Третій параграф​</p>​</div>​

// const firstChild = container.firstElementChild;
// console.log(firstChild);//* Контейнер: <div id=​"container">​…​</div>​<p>​Перший параграф​</p>​<p>​Другий параграф​</p>​<p>​Третій параграф​</p>​</div>​

//! Завдання наступне:

// <span id="text">Наведіть мишу на цей текст</span>
//? Що відбудеться при виконанні цього скрипта?
// const paragraph = document.getElementById("text");
// paragraph.addEventListener("mouseenter", function () {
//   this.style.backgroundColor = "red";
// });
//* Відповіді: Фон  тексту стане червоним

//! Завдання наступне:
//* HTML
// <ul id="parent-list">
//    <li>Item 1</li>
//     <li>Item 2</li>
//     <li>Item 3</li>
//     <li>Item 4</li>
//     <li>Item 5</li>
// </ul>

//* CSS
// ul {
//    list-style-type: none;
// }
// li {
//  cursor: pointer;
//  }
// .selected {
//   color: red;
//   }
//* JS
// document.getElementById('parent-list').
//   addEventListener('click', function(event) {
//     if (event.target.tagName === 'LI') {
//         const items = document.querySelectorAll('li');
//         items.forEach(function(item) {
//             item.classList.remove('selected');
//         })
//         event.target.classList.add('selected');
//     }
//* Відповідь: Код буде встановлювати червоний колір тексту для натиснутого елемента, а також знімати попередню позначку з інших елементів.

//! Завдання наступне:
//? Що буде виведено в консоль?
// const user = {email: "abc@gmail.com", nickname: "abc", age: 30};
// const {nick, age, email = "yyy"} = user;
// console.log(nick, age, email);
//* Відповіді: undefined 30 abc@gmail.com.
//* Ми деструктуризуємо об'єкт і витягуємо його властивості, вказавши для email дефолтну властивість.
//* По порядку:
//* 1. Ключа nick немає, тому буде undefined
//* 2. Ключ age є, тому беремо його значення 30.
//* Ключ email теж є, тому беремо його значення abc@gmail.com, а не дефолтне (яке застосується тільки якщо у нашому об'єкі user не буде ключа email).

//! Завдання наступне:
//? Що буде виведено в консоль?
// function foo() {
//   console.log("This is a function!");
// }
// console.log(JSON.stringify(foo));
//* Відповіді: undefined - При спробі перетворити функцію у JSON результатом буде undefined , оскільки JSON не може представляти функції. JSON (JavaScript Object Notation) призначений для представлення структур даних, таких як об'єкти та масиви, у вигляді рядка. Він не може включати функції.

//! Завдання наступне:
//? Що буде виведено в консоль?
//* Збереження об'єкта
// function saveObject(key, obj) {
//   localStorage.setItem(key, JSON.stringify(obj));
// }

// Отримання об'єкта
// function getObject(key) {
//   const data = localStorage.getItem(key);
//   return data ? JSON.parse(data) : null;
// }

// // Видалення об'єкта
// function removeObject(key) {
//   localStorage.removeItem(key);
// }

// const user = { name: "John", age: 30 };
// saveObject("user", user);
// console.log(getObject("user"));
// removeObject("user");
// console.log(getObject("user"));
//* Відповіді:{ name: 'John', age: 30 } null - Функція saveObject зберігає об'єкт у вигляді JSON-рядка в localStorage. Функція getObject отримує цей рядок і парсить його назад в об'єкт – бачимо в консолі об’єкт. Функція removeObject видаляє об’єкт зі сховища, тому вдруге в консоль виводиться null.

//! Завдання наступне:
//* В якому порядку будуть виведені консолі?
// setTimeout(() => console.log(1), 0);

// console.log(2);

// new Promise((res) => {
//   console.log(3);
//   res();
// }).then(() => console.log(4));

// console.log(5);
//* Відповіді: 2 3 5 4 1 - :blue_heart: Спочатку виконається весь синхронний код – 2 3 5, колбек всередині new Promise виконується синхронно. Далі всі асинхронні задачі діляться на мікро- і макротаски.Обробка проміса – це мікротаска, тому вона виконається раніше, а колбек у setTimeout виконається в останню чергу, оскільки це макротаска, навіть не дивлячись на те, шо час затримки – 0 мс. Отже правильна відповідь 2 3 5 4 1.

//! Завдання наступне:
//? Що буде виведено в консоль?
// function fetchData(statusCode) {
//   return fetch(`https://httpstat.us/${statusCode}`).then((response) => {
//     if (response.ok) {
//       return response;
//     } else {
//       throw new Error(`HTTP error! status: ${response.status}`);
//     }
//   });
// }

// fetchData(200)
//   .then((result) => console.log(result))
//   .catch((error) => console.log(error.message));
// fetchData(404)
//   .then((result) => console.log(result))
//   .catch((error) => console.log(error.message));
// fetchData(500)
//   .then((result) => console.log(result))
//   .catch((error) => console.log(error.message));
//  Відповідь - Дані для статусу 200, помилка для 404, помилка для 500.

//! Завдання наступне:
//?сЩо буде виведено в консоль?
function postData() {
  return fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      title: 'foo',
      body: 'bar',
      userId: 1,
    }),
  }).then((response) => response.json());
}

postData().then((result) => console.log(result)); //*
// {
//   "title": "foo",
//   "body": "bar",
//   "userId": 1,
//   "id": 101
// }
//* Функція postData робить POST-запит з JSON-даними. Сервер відповідає створеним об'єктом поста, який виводиться в консоль.

//! Завдання наступне:
//? Що буде виведено в консоль?
// async function fetchData() {
//   throw new Error('Something went wrong');
// }

// async function getData() {
//   try {
//     const data = await fetchData();
//     return data;
//   } catch (error) {
//     return `Caught error: ${error.message}`;
//   }
// }
//* : “Caught error: Something went wrong” - :flag-ua:;

async function fetchPage(pageNumber) {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/posts?_page=${pageNumber}&_limit=5`
  );
  const data = await response.json();
  return data;
}

async function fetchNextPage(currentPageNumber) {
  const nextPageNumber = currentPageNumber + 1;
  return await fetchPage(nextPageNumber);
}

fetchNextPage(1).then((result) => console.log(result));
// //* [
//   { "userId": 1, "id": 6, "title": "...", "body": "..." },
//   { "userId": 1, "id": 7, "title": "...", "body": "..." },
//   { "userId": 1, "id": 8, "title": "...", "body": "..." },
//   { "userId": 1, "id": 9, "title": "...", "body": "..." },
//   { "userId": 1, "id": 10, "title": "...", "body": "..." }
// ]
//* Функція fetchPage отримує дані з API за номером сторінки, а fetchNextPage викликає fetchPage з наступним номером сторінки. Результат виводиться в консоль.
