//! Синтаксис async/await
//! Будь-яка функція може бути асинхронною, якщо перед її оголошенням додати ключове слово async.

//* Для оголошення асинхронної функції перед ключовим словом function додається async.

// async function fetchData() {
//   // ...
// }

//* У функціональному виразі також перед ключовим словом function додається async.

// const fetchData = async function () {
//   // ...
// };

//* Для оголошення асинхронної стрілкової функції перед списком параметрів додається ключове слово async.

// const fetchData = async () => {
//   // ...
// };

//* Для оголошення асинхронного методу об'єкта async додається перед іменем методу.

// const user = {
//   async getUsername() {
//     // ...
//   },
// };

//* Для оголошення асинхронного методу класу також використовується async перед іменем методу.

// class User {
//   async getUsername() {
//     // ...
//   }
// }

//! Значення, що повертається

//* Синтаксис async/await базується на промісах, тому не блокує основний потік виконання програми. Це альтернатива підходу з then/catch для роботи з асинхронним кодом.

//! Що повертає асинхронна функція?

//* Завжди повертає проміс.
//* Якщо функція повертає значення, воно обгортається в проміс.
//* Якщо не повертає значення, створюється проміс із undefined.

// const foo = async () => {
//   return 5;
// };

// foo().then((value) => {
//   console.log(value); // 5
// });
//* Функція foo() повертає 5, але фактично це Promise.resolve(5).

//* Якщо не вказувати значення для повернення, буде створений проміс зі значенням undefined.

// const foo = async () => {
//   // Не вказуємо значення для повернення
// };

// foo().then((value) => {
//   console.log(value); // undefined
// });

//* Оскільки нічого не повертається, результатом буде Promise.resolve(undefined).

//! Оператор await використовується всередині асинхронних функцій (async) для очікування завершення промісу перед тим, як виконання коду продовжиться.
//* await призупиняє виконання асинхронної функції до моменту, коли проміс буде виконано або відхилено.
//? Коли інтерпретатор зустрічає await:
//* Виконання функції призупиняється до завершення промісу.
//* Якщо проміс виконано успішно (fulfilled), await повертає його значення.
//* Якщо проміс відхилено (rejected), виникає помилка.

// const foo = async () => {
//   console.log('Before await');

//   const promiseValue = await new Promise((resolve) => {
//     setTimeout(() => resolve(5), 2000);
//   });

//   console.log('After await', promiseValue);
// };

// foo(); // через 2 секунди виведеться в консоль  "After await" 5

//? Що відбувається в коді?

//console.log('Before await'); //*- виконується синхронно.
//* Інтерпретатор зустрічає await та призупиняє виконання функції foo(), чекаючи завершення промісу.
//* Через 2 секунди проміс виконується (resolve(5)), і його значення (5) зберігається у змінній promiseValue.
//* Код після await продовжує виконуватися.

//!Основні правила використання await

//* await можна використовувати тільки всередині асинхронних функцій (async).
//* await не працює самостійно без async, але async може існувати без await.
//* await призупиняє виконання функції, доки проміс не завершиться.
//* Якщо проміс успішний, await повертає його значення.
//* Якщо проміс відхилено, await генерує помилку, яку потрібно обробляти через try/catch.

//! Взаємозв’язок async та await

//* Асинхронна функція (async) завжди повертає проміс.
//* Будь-яке значення, що повертається з asyncфункції, автоматично обгортається в Promise.resolve().
//* Якщо функція не повертає значення, повернеться Promise.resolve(undefined).

//! HTTP-запити
//* Використання async/await при роботі з HTTP-запитами робить код більш читабельним і простішим у розумінні.
//* Перепишемо функцію fetchUsers з async/await. Спочатку розглянемо її у стандартному вигляді з axios і .then():

// const fetchUsers = () => {
//   axios.get('https://jsonplaceholder.typicode.com/users').then((response) => {
//     console.log(response.data);
//   });
// };

//*Додаємо async перед функцією:

// const fetchUsers = async () => {
//   // ...
// };
//* Використовуємо await, щоб зачекати завершення axios.get та отримати відповідь у змінну response:

// const fetchUsers = async () => {
//   const response = await axios.get(
//     'https://jsonplaceholder.typicode.com/users'
//   );
//   console.log(response.data);
// };

//* Якщо отримані дані потрібно використовувати зовні, повертаємо їх із функції. Оскільки async-функція завжди повертає проміс, обробляємо результат через .then():
const fetchUsers = async () => {
  const response = await axios.get(
    'https://jsonplaceholder.typicode.com/users'
  );
  return response.data;
};

fetchUsers().then((users) => console.log(users));
//* Чому async/await зручніше?
//* Запит виконується без вкладених .then().
//* Код виглядає послідовним, наче виконується синхронно.
//* Легше читати та дебажити

//* async/await робить роботу з HTTP-запитами зрозумілішою та зручнішою у порівнянні зі стандартним підходом на промісах.
