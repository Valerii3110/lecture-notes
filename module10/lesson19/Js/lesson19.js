//! Асинхронний код
//* Виконується першою синхронний код
// console.log("First log");

// setTimeout(() => {
//   //* Виконується третьою, через 2000 мілісекунд (2 секунди)
//   console.log("Second log");
// }, 2000);

//* Виконується другою
// console.log("Third log");
//* Функція setTimeout() відпрацьовує синхронно й реєструє відкладений виклик переданої callback-функції. Ця функція буде викликана асинхронно, через вказаний проміжок часу.
//* Послідовність подій:

//* 1. Виконується синхронний console.log("First log");, і в консоль виводиться "First log".
//* 2. Виконується setTimeout(), який синхронно ставить передану функцію в асинхронну чергу на виконання. Але через вказану затримку в 2000 мілісекунд (2 секунди), виконання цієї функції відкладається на цей час.
//* 3.Виконуєтья синхронний console.log("Third log");, і в консоль виводиться "Third log".
//* 4.Після 2 секунд виконується асинхронний виклик функції, переданої в setTimeout(), і в консоль виводиться "Second log".

//! Багатопотоковість

//TODO Синхронний однопотоковий підхід — ти сам спочатку готуєш каву, потім тости і подаєш їх, після чого прибираєшся на кухні.
//! Асинхронний однопотоковий підхід —- ти починаєш готувати каву і встановлюєш таймер, потім починаєш готувати тости і так само встановлюєш таймер. Доки кава і тости готуються, ти прибираєш на кухні. Коли таймери спрацьовують, ти знімаєш з вогню каву, дістаєш тости і подаєш їх.
//* Багатопотоковий підхід (паралелізм) — ти наймаєш двох помічників. Одного — для приготування кави, а іншого — для тостів. Тепер у тебе є проблема управління помічниками (потоками), щоб вони не конфліктували один з одним на кухні під час спільного використання ресурсів.

//! Тайм-аут

//* Внутрішній таймер-планувальник браузера дозволяє відкладати виклик функції на певний період часу. Для цього є тайм-аути та інтервали, вони контролюють, коли і як часто викликається функція. Таймери реалізовані в браузері, а не вбудовані в мову, і доступні на глобальному об'єкті window.

//todo Метод setTimeout() дозволяє запланувати одноразовий виклик функції через певний час.

// const timerId = setTimeout(callback, delay, arg1, arg2,.., arg100);

//* callback — функція, виклик якої необхідно запланувати;
//* delay — час у мілісекундах, через який callback-функція буде викликана один раз.
//* Додаткові аргументи (arg1, arg2 тощо) не обов’язкові і будуть передані callback функції під час виклику. Результатом виклику setTimout() буде цифровий ідентифікатор створеного таймера, який потім може бути використаним для його подальшого скасування.

//! Скасування тайм-ауту

//todo Метод clearTimeout(id)приймає ідентифікатор таймера та “очищає його”, тобто видаляє реєстрацію відкладеного виклику функції з черги.
// const greet = () => {
//   console.log("Hello!");
// };

// const timerId = setTimeout(greet, 3000);

// clearTimeout(timerId);
//* Приклад:

//* HTML
//  <button type="button" class="btn js-set">Set timeout</button>
// <button type="button" class="btn js-clear">Clear timeout</button>

//* CSS
// body {
//   margin: 16px;
//   text-align: center;

// }

//* JS
// const setBtn = document.querySelector(".js-set");
// const clearBtn = document.querySelector(".js-clear");
// let timeoutId;

// setBtn.addEventListener("click", () => {
//   timeoutId = setTimeout(() => {
//     console.log("I love async JS!");
//   }, 2000);
// });

// clearBtn.addEventListener("click", () => {
//   clearTimeout(timeoutId);
//   console.log(`Timeout with id ${timeoutId} has stopped!`);
// });

//* * Кожного разу при натисканні на кнопку Set timeout буде створюватися новий таймер, якому буде присвоєно новий ідентифікатор.
//* * Натискання на кнопку Clear timeout очистить відповідний таймер за переданим числовим ідентифікатором.
//* * Якщо потрібно очищати всі таймери, можна, наприклад, зберігати ідентифікатори всіх запущених таймерів у вигляді масиву, перебирати його та послідовно очищати.

//! Інтервал
//todo Метод setInterval() — це простий спосіб повторення коду знову і знову з певним інтервалом.
//* Синтаксис і параметри такі самі, як у setTimeout().
// const intervalId = setInterval(callback, delay, arg1, arg2, ...);
//* Результатом виклику setInterval() буде цифровий ідентифікатор створеного таймера, який потім може бути використаним для його подальшого скасування.
//! На відміну від setTimeout(), інтервал запускає виконання функції не один раз, а регулярно повторює її через вказаний проміжок часу.

//* Приклад:

//* HTML
//  <button class="btn js-start">Start</button>

//* CSS
// body {
//   margin: 16px;
//   text-align: center;

// }

//* JS
// const startBtn = document.querySelector(".js-start");

// startBtn.addEventListener("click", () => {
//   const intervalId = setInterval(() => {
//     console.log(`Interval ID: ${intervalId}, ${Math.random()}`);
//   }, 1000);
// });
//* У прикладі будемо кожну секунду виводити в консоль рядок. Використовуємо Math.random(), щоб рядки були різні.
//* У браузерного таймера є мінімально можлива затримка, вона коливається приблизно від 0 до 4 мілісекунд. За стандартом, мінімальна затримка становить 4 мілісекунди, тому різниці між setInterval(cb, 1) і setInterval(cb, 4) немає.
//* Таймер може спрацьовувати рідше, ніж зазначено в параметрі delay. Адже через занадто велике завантаження процесора деякі запуски функцій-інтервалів будуть пропущені. Браузери продовжують виконувати тайм-аути та інтервали, навіть якщо вкладка браузера неактивна, але водночас знижується частота спрацьовування таймерів.

//! Скасування інтервалу
//* Синтаксис
// clearInterval(id);

// const greet = () => {
//   console.log("Hello!");
// };

// const intervalId = setInterval(greet, 3000);

// clearInterval(intervalId);
//* У прикладі вище ми викликали clearInterval(), який виконається раніше, ніж буде викликана функція greet(). Отже, інтервал з intervalId буде видалений і реєстрація відкладеного виклику greet() скасується. Тому в консоль нічого не виведеться.

//* Приклад:
//* У живому прикладі ми додали кнопку скасування інтервалу Stop, клікаючи на неї ми викличемо clearInterval() і передамо ідентифікатор інтервалу, який потрібно зупинити.
//* HTML
// <button class="btn js-start">Start</button>
// <button class="btn js-stop">Stop</button>

//* CSS
// body {
//   margin: 16px;
//   text-align: center;

// }

//* JS
// const startBtn = document.querySelector(".js-start");
// const stopBtn = document.querySelector(".js-stop");
// let intervalId = null;

// startBtn.addEventListener("click", () => {
//   intervalId = setInterval(() => {
//     console.log(`Interval ID: ${intervalId}, ${Math.random()}`);
//   }, 1000);
// });

// stopBtn.addEventListener("click", () => {
//   clearInterval(intervalId);
//   console.log(`Interval with id ${intervalId} has stopped!`);
// });

//* Кожного разу при натисканні на кнопку Start буде створюватися новий інтервал, якому буде присвоєно новий ідентифікатор.
//* Натискання на кнопку Stop очистить відповідний інтервал за переданим числовим ідентифікатором.
//* Якщо потрібно очистити всі інтервали, можна, наприклад, зберігати ідентифікатори всіх запущених інтервалів у вигляді масиву, перебирати його та послідовно очищати.

//! Дата і час
// todo Створення дати
//* Екземпляр класу Date — це об'єкт, що відображає певний момент часу. Створення дати без аргументів повертає об'єкт, що зберігає дату і час на момент його ініціалізації, тобто поточні дату і час.
// const date = new Date();

// console.log(date); //* Tue Jul 08 2025 07:07:15 GMT+0300 (за східноєвропейським літнім часом). У рядковому перетворенні об'єкт повертає результат виклику вбудованого методу toString(), тому у першому лозі ми отримаємо рядок, а не об'єкт.

// todo Встановлення дати
//*Створюючи екземпляр класу Date, можна налаштувати різні формати відображення даних.
//* Нижче приклад, де до класу Date передають рядок, який описує тільки дату.
// const date = new Date("2030-03-16");
// console.log(date); //* "Sat Mar 16 2030 00:00:00 GMT+0200"(за східноєвропейським стандартним часом)

//* Тут до Date передали рядок, де дата і час розділяються великою літерою T (time).
// const date = new Date("2030-03-16T14:25:00");
// console.log(date); //* Sat Mar 16 2030 14:25:00 GMT+0200 (за східноєвропейським стандартним часом)
//* Можна передати тільки рік, рік і місяць, або повну дату, включно з числом і часом.
// console.log(new Date("2030")); //* "Tue Jan 01 2030 02:00:00 GMT+0200"
// console.log(new Date("2030-03")); //* "Fri Mar 01 2030 02:00:00 GMT+0200"
// console.log(new Date("2030-03-16")); //* "Sat Mar 16 2030 02:00:00 GMT+0200"
// console.log(new Date("2030-03-16T14:25:00")); //* "Sat Mar 16 2030 14:25:00 GMT+0200"

//! Інший спосіб створення нової дати — це передати сім чисел, які описують рік, місяць (починається з 0), день, години, хвилини, секунди й мілісекунди. Обов'язкові тільки перші три.
// const date = new Date(2030, 2, 16, 14, 25, 0, 0);
// console.log(date); //* Sat Mar 16 2030 14:25:00 GMT+0200 (за східноєвропейським стандартним часом)

//! Unix час
//* Для комп’ютерів відлік часу рахується в мілісекундах, що минули після опівночі 1 січня 1970 року в часовому поясі UTC (Coordinated Universal Time). Це — Unix час.
//* Під час ініціалізації дати одним числом, воно являє собою кількість мілісекунд, що вже минула з 01.01.1970.

// console.log(new Date(0));
// "Thu Jan 01 1970 03:00:00 GMT+0300 (Eastern European Standard Time)"

// console.log(new Date(15000));
// "Thu Jan 01 1970 03:00:15 GMT+0300 (Eastern European Standard Time)"
//* Вбудований метод getTime() повертає числове значення цієї дати (timestamp) — кількість мілісекунд, що минула з півночі 1 січня 1970 року.

// const date = new Date();
// console.log(date.getTime()); //* 1624021654154
//* Це число унікальне й ніколи не повториться, тому що момент часу унікальний і завжди тільки збільшується.
//**Зручність цього формату полягає в тому, що можна відображати точні моменти часу у вигляді одного числа і не турбуватися про дати, рядки й часові пояси. Адже можна отримати всю необхідну інформацію, коли необхідно. */

//! Метод Date.now()
//* Ми вже розглядали приклад створення об'єкта часу. У нього є метод getTime, який дозволяє отримати числове представлення моменту часу в кількості мілісекунд.
// const date = new Date();
// console.log(date.getTime()); //* 1751962541927
//? У разі, коли все, що потрібно, це числове представлення моменту часу, немає сенсу створювати цілий об'єкт. Можна використовувати метод Date.now() — це швидкий і зручний спосіб отримати поточний час у вигляді мілісекунд
// const time = Date.now(); //* 1751962541927
// console.log(Date.now()); //* 1751962541927

//* Якщо ти хочеш виміряти, скільки часу займає виконання деякого коду, можна зробити так:

// const startTime = Date.now();

// // Твій код, виконуваний упродовж деякого часу
// for (let i = 0; i <= 100; i += 1) {
//   console.log(i);
// }

// const endTime = Date.now();
// const elapsedTime = endTime - startTime;

// console.log(`Elapsed time: ${elapsedTime} ms`); //*test.js:0- test.js:100 Elapsed time: 6 ms
//* Зберегти час до події.
//* Зберегти час після події.
//* Порахувати різницю між кінцевим і початковим часом.

//! Геттери і сеттери

// todo Екземпляр класу Date має безліч методів для читання та запису значень дати і часу. Методи повертають або присвоюють рік, місяць, день місяця або тижня, годину, хвилину, секунду і мілісекунду для кожного екземпляра.

//! Геттери використовуються для читання всієї дати або окремої складової. Значення, що повертається, залежить від поточного часового поясу, встановленого на комп'ютері.

// const date = new Date("March 16, 2030 14:25:00");
// console.log("Date: ", date); //* Date:  Sat Mar 16 2030 14:25:00 GMT+0200 (за східноєвропейським стандартним часом)

// //* Повертає день місяця від 1 до 31
// console.log("Day: ", date.getDate()); //* Day:  16

// //* Повертає день тижня від 0 до 6, починається з неділі
// console.log("Day of the week: ", date.getDay()); //* Day of the week:  6

// //* Повертає місяць від 0 до 11
// console.log("Month: ", date.getMonth()); //* Month:  2

// //* Повертає рік з 4 цифр
// console.log("Full year: ", date.getFullYear()); //* Full year:  2030

// //* Повертає години
// console.log("Hours: ", date.getHours()); //* Hours:  14

// //* Повертає хвилини
// console.log("Minutes: ", date.getMinutes()); //* Minutes:  25

// //* Повертає секунди
// console.log("Seconds: ", date.getSeconds()); //* Seconds:  0

// //* Повертає мілісекунди
// console.log("Milliseconds: ", date.getMilliseconds()); //* Milliseconds:  0

// //* Все, що можна прочитати — можна записати, методи для запису починаються з префікса set.

// const date = new Date("March 16, 2030 14:25:00");

// date.setMinutes(50);
// console.log(date); //*  Sat Mar 16 2030 14:50:00 GMT+0200 (за східноєвропейським стандартним часом)

// date.setFullYear(2040);
// console.log(date); //* Fri Mar 16 2040 14:50:00 GMT+0200 (за східноєвропейським стандартним часом)

// date.setMonth(4);
// console.log(date); //* Wed May 16 2040 14:50:00 GMT+0300 (за східноєвропейським літнім часом)
